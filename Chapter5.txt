Lab 5-1:

107/494

1. Address of DllMain is 0x1000D02E, .text section.


2. gethostbyname import is located at 0x100163CC, .idata section. 


3. gethostbyname is called 9 times (graph shown in Lab5-1q2.png).


4. 0ff_10019040 is moved into register eax. Following the link to off_10019040  shows the string "[This is RDO]pics.practicalmalwareanalysis.com", so pics.practicalmalwareanalysis.com will be the DNS request made.


5. The answers in the textbook said there are 23 local variables at 0x10001656, but I can only see 20. Turns out this is due to IDA Pro free version showing fewer things than the full paid version.


6. As above, possible discrepancies between free and paid versions of IDA Pro. The free version counts 1 parameter.


7. "\cmd.exe /c " is at 0x10095B34.


8. Looks like there is output being written in cmd. "Hi,Master [timestamp]", "WelCome Back...Are You Enjoying Today?", etc. Machine uptimes and idle times are displayed, plus stuff about encrypting a magic number for this remote shell session.

Following the XREFs for these strings shows they are pushed to a stack when these functions are called.

The function recv is the first function called after the cmd string is pushed to a stack. MSDN says this is to do with sockets and incoming data, backing up the earlier suspicion that this DLL sets up a remote shell session for the attacker on the infected machine.


9. wVersionRequested appears to be pushed onto the stack near the use of dword_1008E5C4 at 0x10001678, so the path taken looks like it's decided by which version of Windows the victim is running.

eax is moved into the dword register, and the value of eax is set in the line above with a call to sub_10003695. Investigating this function does indeed confirm that the value of dword_1008E5C4 is determined by which version of Windows is being run.


10. I found the memcmp with robotwork by searching for the text "robotwork", which IDA Pro has helpfully added as a comment.

There is a jnz (jump if not zero) command at 0x10010461 - if memcmp returns zero (ie. string == robotwork) the jump will not be taken, the value at address [ebp+s] will be pushed to the stack and sub_100052A2 will be called. This function takes a socket as an argument and calls functions based on querying registry keys, so it could be transmitting data about registry values. 

"SOFTWARE\\Microsoft\\Windows\\CurrentVersion" appears as a string before RegOpenKeyA, so SOFTWARE\Microsoft\Windows\CurrentVersion is being queried. "WorkTime" appears before RegQueryValueExA, so this is the value in the key which is being queried. This information appears to be used in the output "[Robot_WorkTime :]".


11. PSLIST (0x10007025) changes the value of dword_1008E5C4 to 1 and calls sub_10036C3, which gets extended information about the version of Windows by calling GetVersionExA. 


12. Graph is shown in Lab05-01q12.png on the repo.

GetSystemDefaultLangID is the only API call made by sub_10004E79 directly. sub_10004E79 calls sub_100038EE, which calls send, so sub_10004E79 could be renamed along the lines of sendLangID


13. DllMain calls 7 functions directly (depth 1). At depth 2, the graph shows many, many more calls and has 100 nodes.


14. eax is pushed to the stack, then Sleep is called. 3E8 is a hex value and converts to 1000, so sleep is whatever value was given by the atoi call multiplied by 1000. So the result of atoi in seconds.

0x10001346 adds 13 (0D in hex) to the value held in eax, which is then pushed to the stack. atoi is called on "[This is CTI]30 "with this offset, converting "30" to an integer value. 30 * 1000 = 30,000ms, so the program will sleep for 30 seconds.


15. The three parameters taken by socket are af, type and protocol, all of which are int values. 6, 1 and 2 are pushed to the stack starting at 0x100016FB, so the function call is socket(2, 1, 6).


16. af 2 means the address family used is IPv4 (AF_INET). type 1 is SOCK-STREAM, which uses TCP for streaming data. protocol 6 is IPPROTO_TCP, which makes sense with the previous two values.

Adding these as symbolic constants in place of the numbers makes the assembly code much more readable.

This socket will be configured for IPv4 over TCP, so it's likely to be used for HTTP.


17. opcode 038 ED appears at address 0x100061DB (instruction:   in    eax, dx). 564D5868h evaluates to the 'magic string' VMXh - the cmp command at the next address compares ebx (value 0) to this string. 
 
The three install functions that call this detection function (shown in graph La05-01q17.png) all 
have a line with the comment "Found Virtual Machine,Install Cancel." if a VM is detected with this magic string.


18. Address 0x1001D988 seems to be the start of a string of apparently garbage characters which also appears as one line in the Strings window.


19. Unable to run Python scripts in IDA Pro freeware version.


20. Right-click and convert to string. Or just press A, apparently.


21. The script gets the current location of the cursor using the ScreenEA() function. i is an offset which is used to make the script process 50 bytes, starting with the one currently marked by the cursor. The value of each byte is XOR'd with 0x55 and the current byte being operated on is patched with the result, the decoded_byte. 




